\section{Protocol}
As described earlier, every {\tt Postman::Message} is of the form

\begin{verbatim}
nameservice_version msg_size msg_type msg_content
\end{verbatim}
The following subsections describe {\tt msg\_type} and the contents within {\tt msg\_content}.
All {\tt msg\_type}'s are defined within {\tt Postman} in an enum called {\tt MessageType}.
Anything related to the name directory will be explained in a later section, though in a nutshell, {\tt nameservice\_version} allow the receiver to determine which portion of the logs should be attached in a reply.
{\bf Notice that all replies except {\tt CONFIRM\_TERMINATE} has partial logs attached}, I will refer them as {\tt log\_delta}.

\subsection{Request: \tt ASK\_NS\_UPDATE}
This request can happen for the servers when a new server joins.
This is discussed in details in {\tt NEW\_SERVER\_EXECUTE}.
The message content is empty, because all message already has a local version number of name directory.

\subsection{Reply: \tt NS\_UPDATE\_SENT}
The message content contains {\tt log\_delta}, which is used by servers/clients to update their local name directory.

\subsection{Request: \tt I\_AM\_SERVER}
This request is sent within {\tt rpcInit()}, and it is delivered to the binder.
The message content is the port number that servers use to listening incoming messages.
This request is needed because I decided to make connections last within a scope, and the binder needs to start connections to servers.
In effect, this request register a server in the binder's name directory.

\subsection{Reply: \tt SERVER\_OK}
This is binder's reply to {\tt I\_AM\_SERVER}.
The message contains
\begin{verbatim}
server_id log_delta
\end{verbatim}
The {\tt server\_id} is generated by the binder, which the server uses to set its global variable {\tt Global::server\_id}.
Effectively, a server \emph{is} a server if and only if {\tt server\_id} $\neq$ {\tt static\_cast<unsigned int>(-1)}.

\subsection{Request: \tt Register}
Only the server can send this message.
This request register a {\bf unique} {\tt Function} to the binder.
All subsequent register for methods that has the same signiture, determined by {\tt operator<}, will cause the server to update the skeleton locally -- no message is sent.
The message contents contain
\begin{verbatim}
server_id fn_name_len fn_type_len fn_name fn_types
\end{verbatim}
where {\tt fn\_name} is the name of the function and {\tt fn\_types} are the types of function (as integers), {\tt fn\_name\_len} and {\tt fn\_type\_len} are lengths of {\tt fn\_name} and {\tt fn\_type}, respectively -- I will refer to this quadruple as the binary representation of {\tt Function}.

\subsection{Request: \tt LOC\_REQUEST}
This message can only be sent by a client, who wants to ask the binder for a server suggestion.
The message contents contain just the binary representation of a {\tt Function}.

\subsection{Reply: \tt LOC\_REQUEST\_REPLY}
This is binder's reply to a client's location request.
If the binder has a suggestion, then the message contents contain
\begin{verbatim}
true log_delta server_id
\end{verbatim}
The client will update the name directory, as always for all replies, with {\tt log\_delta}, and then it resolves {\tt server\_id} using its local name directory -- this must succeed since {\tt log\_delta} brings client to the same version of the name directory as the binder's.
If the binder doesn't have a suggestion, then the message conents contain
\begin{verbatim}
false log_delta NO_SERVER_AVAILABLE
\end{verbatim}
where {\tt NO\_SERVER\_AVAILABLE} is an error number (arguably unecessary).

\subsection{Request: \tt EXECUTE}
This is called by the client to the server for a task execution.
The message contents contain
\begin{verbatim}
func args
\end{verbatim}
where {\tt func} is the binary representation of {\tt Function}, and {\tt args} contains 0 or more of arrays (scalars are treated as arrays of size 1) {\bf that are input arguments}.

\subsection{Reply: \tt EXECUTE\_REPLY}
This is the server's execution reply to the client.
The message contains
\begin{verbatim}
retval args
\end{verbatim}
where {\tt retval} is the integer return value of the RPC call.
If the skeleton returns an error, {\tt retval} will be {\tt SKELETON\_FAILURE} (see later sections).
On the other hand, {\tt args} contains the {\bf output arguments}, which overwrite the corresponding items in the same {\tt args} that the client used to send the execute request.

\subsection{Request: \tt TERMINATE}
This request is sent by the client to the binder.
When the binder gets this message, it send the a terminate request to the servers.
Then the servers will ask for confirmation to the binder.
The message contents contain an empty string.

\subsection{Request/Reply: \tt CONFIRM\_TERMINATE}
This message is a bit more interesting.
It serves as both request and reply, both ways, from servers to the binder as a request, and then from the binder to servers as a reply.
The message contains
\begin{verbatim}
is_terminate
\end{verbatim}
Notice {\tt is\_terminate} is only used when servers get the binder's reply.
Since the reply comes from the binder, if {\tt is\_terminate} is true, then the terminate request is geniune, and servers will proceed to termination.
{\bf However, the binder doesn't follow the specification about terminating after all servers have terminated; the binder terminates when it replies {\tt CONFIRM\_TERMINATE} to all servers.}
I guess this is design decision due to {\tt ScopedConnection}, because every connection must disconnect at the end of any RPC methods in {\tt rpc.h}, if not earlier.
I chose to do it this way because I would like to keep the number active connections low, so that the binder and servers can serve more requests.
After all, there is an upper limit in the number of connections that a socket can listen to.
The downside is that the binder no longer knows if a server is active anymore, unless the binder tries to connect to a potentially dead server.

\subsection{Request/Broadcast: \tt NEW\_SERVER\_EXECUTE}
The message content is an empty string.
The server sent this request to the binder when {\tt rpcExecute()} runs.
When the binder gets this request, the binder will broadcast this request to all servers.
If a server is dead, the the binder would remove it from the binder's name directory.
If servers are alive, then the servers would send a {\tt ASK\_UPDATE\_NS} request to the binder.
Therefore, the servers' name directory will become {\bf mostly} (not completely) up-to-date.
