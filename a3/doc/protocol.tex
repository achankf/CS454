\section{Protocol}
As described earlier, every {\tt Postman::Message} is of the form

\begin{verbatim}
nameservice_version msg_size msg_type msg_content
\end{verbatim}
The following subsections describe {\tt msg\_type} and the contents within {\tt msg\_content}.
All {\tt msg\_type}'s are defined within {\tt Postman} in an enum called {\tt MessageType}.
Anything related to the name directory will be explained in a later section, though in a nutshell, {\tt nameservice\_version} determines which logs should be send back to the original request sender, so that the sender can use the log to update its name directory.
{\bf Notice that all replies except {\tt CONFIRM\_TERMINATE} has partial logs attached}, I will refer them as {\tt log\_delta}.

\subsection{Request: \tt ASK\_NS\_UPDATE}
This request can happen for both clients and servers.
{\bf Notice that this request is not strictly between clients/servers and the binder}.
I will cover this later.
The message content is empty, because all message already has a local version number of name directory.

\subsection{Reply: \tt NS\_UPDATE\_SENT}
The message content just contains {\tt log\_delta}, which is used by servers/clients to update their local name directory.

\subsection{Request: \tt I\_AM\_SERVER}
This request is called by any server within {\tt rpcInit()}, and it is delivered to the binder.
The content is the port number of the server for listening connections.
This request is needed because the binder only knows the ipv4 address and the port number that the server is used to send messages, not the port number for listening connections.
In effect, this request register a server in the binder's name directory.

\subsection{Reply: \tt SERVER\_OK}
This is binder's reply to {\tt I\_AM\_SERVER}.
The message contains
\begin{verbatim}
server_id log_delta
\end{verbatim}
It contains an {\tt unsigned int} id generated by the binder, which the server uses to set its global variable {\tt Global::server\_id}.
Effectively, a server \emph{is} a server if and only if {\tt server\_id} $\neq$ {\tt static\_cast<unsigned int>(-1)}.

\subsection{Request: \tt Register}
Only the server can send this message.
This request tries to register a {\bf unique} {\tt Function} to the binder.
All subsequent register for methods that has the same signiture, determined by {\tt operator<}, will cause the server to update the skeleton locally -- no message is sent.
The message contains
\begin{verbatim}
server_id fn_name_len fn_type_len fn_name fn_types
\end{verbatim}
where {\tt fn\_name} is the name of the function and {\tt fn\_types} are the types of function (as integers), {\tt fn\_name\_len} and {\tt fn\_type\_len} are lengths of {\tt fn\_name} and {\tt fn\_type}, respectively -- I will refer to this quadruple as the binary representation of {\tt Function}.

\subsection{Request: \tt LOC\_REQUEST}
This message can only be sent by a client, who wants to ask the binder for a server suggestion.
The message contains just the binary representation of {\tt Function}.

\subsection{Reply: \tt LOC\_REQUEST\_REPLY}
This is binder's reply to the client location request.
If the binder has a suggestion, then the message contains
\begin{verbatim}
true log_delta server_id
\end{verbatim}
The client will update the name directory, as always for all replies, with {\tt log\_delta}, and then it resolves {\tt server\_id} using its local name directory -- this must succeed since {\tt log\_delta} brings client to the same version of the name directory as the binder's.

If the binder doesn't have a suggestion, then the message contains
\begin{verbatim}
false log_delta NO_SERVER_AVAILABLE
\end{verbatim}
where {\tt NO\_SERVER\_AVAILABLE} is an error number.

\subsection{Request: \tt EXECUTE}
This is called by the client to the server.
The message contains
\begin{verbatim}
func args
\end{verbatim}
where {\tt func} is the binary representation of {\tt Function}, and {\tt args} contains 0 or more of the following pair
\begin{verbatim}
argsi_size args_i_0_data ... args_i_j_data
\end{verbatim}
In other words, the array (scalars are treated as arrays of size 1) of the $i^{th}$ argument in {\tt args} {\bf that are input arguments}.

\subsection{Reply: \tt EXECUTE\_REPLY}
This is the server's execution reply to the client.
The message contains
\begin{verbatim}
retval args
\end{verbatim}
where {\tt retval} is the integer return value of running the skeleton function.
Similarly, {\tt args} contains the {\bf output arguments} only, which the client uses to overwrite the corresponding items in the same {\tt args} that the client used to send the execute request.

\subsection{Request: \tt TERMINATE}
This request is sent by the client to the binder.
When the binder gets this message, it send the a terminate request to the servers.
Then the servers will ask for confirmation, which is covered in the next subsection.
The confirmation is needed because the only information that the servers know about the binder is the ipv4 address and the listen port.
However, the binder doesn't use the listen port to send the terminate request, obviously.
The message is an empty string.

\subsection{Request/Reply: \tt CONFIRM\_TERMINATE}
This message is a bit more interesting.
It serves as both request and reply, both ways, from the servers to the binder as a request, and then from the binder to the servers as a reply.
The message contains
\begin{verbatim}
is_terminate
\end{verbatim}
Notice {\tt is\_terminate} is only used when the servers get the binder's reply.
Since the reply comes from the binder, if {\tt is\_terminate} is true, then the terminate request is geniune, and the servers will proceed to termination.
{\bf However, the binder doesn't follow the specification about terminating after all servers have terminated.}
I guess this is design decision due to {\tt ScopedConnection}.
Notice that every connection must disconnect at the end of any RPC methods in {\tt rpc.h}, if not earlier.
This is because I would like to keep the number active connections low, so that the binder and the server can serve more requests.
After all, there is an upper limit in the number of connections that a socket can listen to.
The downside is that the binder no longer knows if a server is active anymore, unless the binder tries to connect to a potentially dead server.

\subsection{Request/Broadcast: \tt NEW\_SERVER\_EXECUTE}
The message content is an empty string.
The server sent this request to the binder when {\tt rpcExecute()} runs.
When the binder gets this request, the binder will broadcast this request to all servers.
If a server is dead, the the binder would remove it from the binder's name directory.
If servers are alive, then the servers would send a {\tt ASK\_UPDATE\_NS} request to the binder.
Therefore, the servers' name directory will become {\bf mostly} (not completely) up-to-date.
