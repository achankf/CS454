\section{Name Directory And {\tt rpcCacheCall}}
To (mostly) synchronize name directories, each machine contains a local in-memory log, versioned by timestamp ordering.
The log is represented by a {\tt std::vector(LogEntry)}.
Thus, the version of the name directory is simply the size of the vector.
{\tt LogEntry} is one of the following:

\begin{itemize}
\item
\begin{verbatim}
NEW_NODE id ip_addr listen_port
\end{verbatim}
where {\tt id} is an unique incremental id generated by the binder, {\tt ip\_addr} is the ipv4 address of a server machine, and {\tt listen\_port} is the port number that the machine uses to listen incoming messages.
\item
\begin{verbatim}
KILL_NODE id
\end{verbatim}
This entry removes entries that are related to the server machine of {\tt id}.
\item
\begin{verbatim}
NEW_FUNC id func
\end{verbatim}
This entry associates a function definition to the server machine of {\tt id}.
\end{itemize}

Notice that a server always has up-to-date information about itself, because each request that affects the binder's name directory has a reply with the changes attached.
Also, when a server runs {\tt rpcExecute}, it forces the binder to broadcast {\tt NEW\_SERVER\_EXECUTE}, which causes all servers to ask the binder for the latest updates.

\subsection{Cases When Name Directory Is Not Up-to-date}
Recall my design decision that all remote connections are scoped.
This means the binder doesn't know immediately when a server dies (for whatever unnatural reasons).
Thus, {\tt KILL\_NODE} entries are added lazily to the logs when the binder realizes a server is down.
This means some entries actually can be zombies.
The binder knows whether a server live in the following circumstances:
\begin{itemize}
\item
The binder broadcast {\tt NEW\_SERVER\_EXECUTE} to every server.
\item
The client ask for a {\tt LOC\_REQUEST}, which causes the binder to look for a suggestion.
To make a suggestion, the binder needs to probe candadate servers by openning connections.
\item
The binder broadcast {\tt TERMINATE} to every server.
However, there is no point to update the name server because the system is terminating.
\end{itemize}

Though, zombie entries are not problematic, because they only cause {\tt rpcCacheCall} to probe more servers, but not the binder.
If a server tries to register a {\tt Name} that is already a zombie (with the same ip address and port), the binder assigns a new id and replaces all old entries.
For clients, there are 2 cases in a successful probe:
\begin{itemize}
\item
All records related to the server is still up-to-date (i.e.\ not zombies).
In this case, the client proceed with the call.
\item
Records related to the server are no longer up-to-date (i.e.\ zombies).
This {\bf only} happens when a server is dead and it reboots, such that the listen port is the same as before.
There are 2 subcases:
\begin{itemize}
\item
The server re-registers functions before the client tries to call them.
In this case, the server will accept the request and will run the call, which is fine because the specification guarantees same functionality for each unique method across servers.
\item
The server is slow and the client catch on before registration is complete.
In this case, the server reply with the error {\tt FUNCTION\_NOT\_REGISTERED}.
The client moves on to the next candadate.
\end{itemize}
\end{itemize}

In any case, I think it is reasonable to assume that servers stay up with little down time, so the size of logs is amortized to $O(1)$ -- mostly consist of an integer (zero) that represents the number of log entries and nothing follow.
