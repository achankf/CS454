Slide 1

layers
- platform
- middleware
- applications

advantage of server/client
- more efficient division of labor
- horizontal and vertical scaling of resources
- better price/performance on client machines
- ability to use familiar tools on client machine
- client access to remote data (via standards)
- full DBMS functionality provided to client workstation

problems with > 1 client and 1 server
- server forms bottleneck, single point of failure, scaling difficult

think client
- run GUI on client while application execute on a possibly remote server

remote procedure call
- caller makes a procedure call; if it's a local procedure, then handle it normally; otherwise, handle it as a remote procedure

object management architecture
- object-oriented
- common object request broker (CORBA) - middleware

design requirement of distributed systems
- performance
	- distribution - opportunities for parallelism
	- scalability
	- avoid bottlenect
	- difference b/w bandwidth and latency
	- caching and replication
- quality of service
	- functional
	- non-functional: performance, reliability, availability
- dependability
	- reliability
		- measurement of success with which a system conforms to some functional requirements
		- probability of non-failure
	- availability
		- fraction of time that a system meets its specs
		- probability that system is operational in a given period
- security
	- communication, distributed resources, infrastructure attacks
	- unauthorized usage
	- problems: threats to processes and communication channels, denial of service attacks
	- issues: privacy, authentication, availability, integrity

redundancy
- hardware
- software
	- multiple processes: one dies, the other takeover
	- data: transactional

Slide 2

protocol - defines format and ordering of messages

OSI model
- applicaiton - support network application; FTP, HTTP, etc.
- presentation
- session
- transport - host to host data transfer; TCP, UDP
- network - routing; IP
- data link - data transfer b/w neighbouring network element; X.25, Ethernet, packet radio, etc.
- physical - bits "on the wire"

- message format: stack-based, physical...application then the data

TCP
- connection-oriented
- reliable transport
- flow control
- congestion control
- doesn't provide timing, bandwidth guarantee

UDP
- unreliable data transfer
- doesn't provide connection setup, reliability, flow control, timing, or bandwidth guarantee

IP address classes
A	0   - 127   0
B	128 – 191	10
C	192 – 223	110
D	224 – 239	1110
E	240 – 254   1111

data transfer
- circuit switching
	- dedicate circuit per call
	- no resource sharing
	- call setup required
	- guaranteed performance
	- resource division - frequency vs time
- packet switching
	- data sent through discrete chunks
	- end-to-end data stream divided into packets
	- resource contention (i.e. congestion)
	- store and forward - packet move one hop at a time
	- delays - nodal processing, queuing, transmission delay, propagation delay

message switching

routing
- datagram network - destination address determines next hop (i.e asking for direction)
- virtual circuit - each packet carries tag, which determines next hop; fixed path

Slide 3

- RPC - extension of the conventional procedure call model
- RMI - remote method invocation; object-oriented; allows object in one process to invoke an object's method in another process
- message based communication - send/receive; non-blocking; receiver doesn't need to be running

data transmission format
- canonical form
- versioning: first byte indicates the format

RPC failures
- client unable to locate server - solution: error code
- request packets are lost - check for acknowledgement and have a timer
- reply packets are lost - timer
- server crashes after receiving packets
	- wait until server reboot and check status
	- give up immediately and report failure
	- client gets no help (easy)
- client crashes after sending packets
	- extermination - keep of log and kill orphans after client reboots
	- reincarnation - divide time into epoches; when client reboot mark a new epoch and kill orphans
	- gentle reincarnation - when broadcast comes in, kill orphans that don't have an owner
	- expiration - timeout

RPC stubs
- generated by compilers

dynamic binding
- separate process called "binder" which provides the following methods
	- register - {name, version, handle, unique id} -> ()
	- deregister - {name, version, unique id} -> ()
	- look up - {name, version} -> {handle, unique id}
- advantages:
	- flexible
	- support multiple servers that support the same interface
	- binder can verify both client and server use the same interface
- disadvantages:
	- overhead
	- bottlenect for large systems

distributed object management
- RMI
- additional complications
- good model
- modules
	- communication module
	- remote reference module

message-based communication
- send/receive
- synchronous - store message in receiving host's local buffer or delivered to the receiver
- asynchronous - sender continues immediately after a send; store in receiving host's local buffer or at the first communication server
- transient - "if not delivered = lost"
- persistent - store in the communication system until message is delivered

Slide 4

requirements on name services
- usage of a convention for unique global naming
- scalability
- consistency
- performance & availability
- adaptability to change
- fault isolation

DNS namespace distribution
- global (top-level)
- administrational (organization)
- managerial (local)

DNS issues
- partitioning
- replication
- caching

DNS navigation
- iterative
	- client-controlled - client asks each DNS server to resolve name
	- server-controlled - client asks one DNS server that resolves the whole name iteratively to the client
- recursive

X.500 Directory service
- Directory user agents (DUA)
- Directory service agents (DSA)
- name tree
- provides read and search

Slide 5 (File Systems)

requirements
- transparency
- concurrent access
- file replication
- tolerate hardward and operating system heterogenity
- security
- fault tolerance
- consistency
- efficiency

architecture
- flat file server
	- use unique file identifiers (UFID) to identify files
	- RPC-based interface
	- not used by application level programs
- directory service
	- map UFID to file name, both ways
- client module
	- API for application program

Sun Network File System
- access transparency
	- no distinction b/w local and remote files
	- virtual file system
	- file handles
- security
	- transmitted via RPC
	- can fake identity
		- overcome by encryption

mounting of file systems
- RPC-based mount protocol
- hard-mounted
	- mostly used in practice
	- user-level process suspended until operation completed
	- application may not terminate gracefully in failure situations
- soft-mounted
	- error message returned to NFS client module to user-level process after small number of retries

note: client needs to explicitly mount nested directories

caching in Sun NFS
- write operations has consistency problems
- write-through caching
	- completely write data to file before replying to client
	- inefficient when write is frequent
- commit operation
	- store write changes in cache memory
	- write to disk when commit

client chaching in NFS
	- cache read operations
		- inconsistency handled by timestamp
			- polling server
			- based on freshness of cached object

	- cache write operations
		- mark modified cache page as dirty and schedule page to be flushed to server asynchronously
	- asynchronous block input/output (bio) daemon
		- read/write done by blocks
		- spacial & temporal locality

file sharing semantics
- single processor - when a read follows a write, the return value of read is the value just written
- distributed system - obsolete values may be returned

4 ways of dealing with shared files in a distributed system:
- unix semantics - every operation on a file is instantly visible to all processes
- session semantics - no changes are visible to other processes until the file is closed
- immutable files - no updates possible
- transaction - all changes occur atomically

Andrew File System (AFS)
- infrequently updated shared files and local user files remain valid for long periods of time
- large local disk cache establishes a working set
	- assume small files
	- reads more than writes
	- sequential access
	- user-locality (used by one user only)
	- burstiness (temporal locality)
- whole-file serving - transfer entire contents to client
- whole-file caching - transfered file will be stored in the client's local disk
- callback promises - ensures cached files are updated after a client calls close()
- file update with one-copy update semantics is inefficient
- does not support concurrent updates

Slide 6

Clock synchronization
- all processes need to agree on the order in which events occur
- logical clocks
- physical clocks (real time)

- physical clock synchronization
	- change in time - dt
	- maximum drift rate - rho
	- 2 clocks can be at most 2(rho)(dt) apart
	- maximum time apart - delta
	- needs to synchronize clock every (delta)/2/(rho)

Christian's algorithm
- one time server (WWV receiver) and all other machines synchronize with the time server
- changes cannot be backward
- apply propagation time (t1-t0-I)/2
	- I - interrupt handling time

Berkeley algorithm
- time daemon polls every machine periodically
- computes average time
- tells other to advance clock or slow clock
- time daemon's time is set manually by operator periodically

Averaging algorithm
- decentralized algorithm
- divide time into fixed length intervals
- T0 - an agreed upon moment in the past
- R - a system parameter
- ith interval is [T0+iR, T0+(i+1)R)
- each machine broadcast its time at the start of an interval
- compute the average
	- discard highest and lowest time values

Internet Network Time Protocol (NTP)
- tree structure
- nodes at lower depth (strata) synchronize with their parents
- if a node fails, it degrades to the next strata
- modes:
	- multicast - periodically transmits time
	- procedure call - similar to Christian's algorithm
	- symmetric - used where high accuracy is needed

synchronized clocks
- at-most-once message delivery
	- each message carries a connection ID and a timestamp
	- server records the most-recent timestamp
	- server rejects any connection with a lower timestamp stored for that connection
	- periodically the current time is written to disk

logical clock synchronization
- happens-before relation (a->b)
	- in same process: if a happens before b, then a->b
	- in different processes: if 'a' is the event of a message, and 'b' is the event of the same message received by another process, then a->b
	- in different processes: processes do not exchange message (i.e. neither a->b nor b->a), these events are concurrent a||b
	- transitivity holds

Lamport's algorithm
- each process has a local counter, Li
- each event e that occurs at process pi is assigned a Lamport timestamp Li(e)
