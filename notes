Slide 1

layers
- platform
- middleware
- applications

advantage of server/client
- more efficient division of labor
- horizontal and vertical scaling of resources
- better price/performance on client machines
- ability to use familiar tools on client machine
- client access to remote data (via standards)
- full DBMS functionality provided to client workstation

problems with > 1 client and 1 server
- server forms bottleneck, single point of failure, scaling difficult

think client
- run GUI on client while application execute on a possibly remote server

remote procedure call
- caller makes a procedure call; if it's a local procedure, then handle it normally; otherwise, handle it as a remote procedure

object management architecture
- object-oriented
- common object request broker (CORBA) - middleware

design requirement of distributed systems
- performance
	- distribution - opportunities for parallelism
	- scalability
	- avoid bottlenect
	- difference b/w bandwidth and latency
	- caching and replication
- quality of service
	- functional
	- non-functional: performance, reliability, availability
- dependability
	- reliability
		- measurement of success with which a system conforms to some functional requirements
		- probability of non-failure
	- availability
		- fraction of time that a system meets its specs
		- probability that system is operational in a given period
- security
	- communication, distributed resources, infrastructure attacks
	- unauthorized usage
	- problems: threats to processes and communication channels, denial of service attacks
	- issues: privacy, authentication, availability, integrity

redundancy
- hardware
- software
	- multiple processes: one dies, the other takeover
	- data: transactional

Slide 2

protocol - defines format and ordering of messages

OSI model
- applicaiton - support network application; FTP, HTTP, etc.
- presentation
- session
- transport - host to host data transfer; TCP, UDP
- network - routing; IP
- data link - data transfer b/w neighbouring network element; X.25, Ethernet, packet radio, etc.
- physical - bits "on the wire"

- message format: stack-based, physical...application then the data

TCP
- connection-oriented
- reliable transport
- flow control
- congestion control
- doesn't provide timing, bandwidth guarantee

UDP
- unreliable data transfer
- doesn't provide connection setup, reliability, flow control, timing, or bandwidth guarantee

IP address classes
A	0   - 127   0
B	128 – 191	10
C	192 – 223	110
D	224 – 239	1110
E	240 – 254   1111

data transfer
- circuit switching
	- dedicate circuit per call
	- no resource sharing
	- call setup required
	- guaranteed performance
	- resource division - frequency vs time
- packet switching
	- data sent through discrete chunks
	- end-to-end data stream divided into packets
	- resource contention (i.e. congestion)
	- store and forward - packet move one hop at a time
	- delays - nodal processing, queuing, transmission delay, propagation delay

message switching

routing
- datagram network - destination address determines next hop (i.e asking for direction)
- virtual circuit - each packet carries tag, which determines next hop; fixed path

Slide 3

- RPC - extension of the conventional procedure call model
- RMI - remote method invocation; object-oriented; allows object in one process to invoke an object's method in another process
- message based communication - send/receive; non-blocking; receiver doesn't need to be running

data transmission format
- canonical form
- versioning: first byte indicates the format

RPC failures
- client unable to locate server - solution: error code
- request packets are lost - check for acknowledgement and have a timer
- reply packets are lost - timer
- server crashes after receiving packets
	- wait until server reboot and check status
	- give up immediately and report failure
	- client gets no help (easy)
- client crashes after sending packets
	- extermination - keep of log and kill orphans after client reboots
	- reincarnation - divide time into epoches; when client reboot mark a new epoch and kill orphans
	- gentle reincarnation - when broadcast comes in, kill orphans that don't have an owner
	- expiration - timeout

RPC stubs
- generated by compilers

dynamic binding
- separate process called "binder" which provides the following methods
	- register - {name, version, handle, unique id} -> ()
	- deregister - {name, version, unique id} -> ()
	- look up - {name, version} -> {handle, unique id}
- advantages:
	- flexible
	- support multiple servers that support the same interface
	- binder can verify both client and server use the same interface
- disadvantages:
	- overhead
	- bottlenect for large systems

distributed object management
- RMI
- additional complications
- good model
- modules
	- communication module
	- remote reference module

message-based communication
- send/receive
- synchronous - store message in receiving host's local buffer or delivered to the receiver
- asynchronous - sender continues immediately after a send; store in receiving host's local buffer or at the first communication server
- transient - "if not delivered = lost"
- persistent - store in the communication system until message is delivered

Slide 4

requirements on name services
- usage of a convention for unique global naming
- scalability
- consistency
- performance & availability
- adaptability to change
- fault isolation

DNS namespace distribution
- global (top-level)
- administrational (organization)
- managerial (local)

DNS issues
- partitioning
- replication
- caching

DNS navigation
- iterative
	- client-controlled - client asks each DNS server to resolve name
	- server-controlled - client asks one DNS server that resolves the whole name iteratively to the client
- recursive

X.500 Directory service
- Directory user agents (DUA)
- Directory service agents (DSA)
- name tree
- provides read and search

Slide 5 (File Systems)

requirements
- transparency
- concurrent access
- file replication
- tolerate hardward and operating system heterogenity
- security
- fault tolerance
- consistency
- efficiency

architecture
- flat file server
	- use unique file identifiers (UFID) to identify files
	- RPC-based interface
	- not used by application level programs
- directory service
	- map UFID to file name, both ways
- client module
	- API for application program

Sun Network File System
- access transparency
	- no distinction b/w local and remote files
	- virtual file system
	- file handles
- security
	- transmitted via RPC
	- can fake identity
		- overcome by encryption

mounting of file systems
- RPC-based mount protocol
- hard-mounted
	- mostly used in practice
	- user-level process suspended until operation completed
	- application may not terminate gracefully in failure situations
- soft-mounted
	- error message returned to NFS client module to user-level process after small number of retries

note: client needs to explicitly mount nested directories

caching in Sun NFS
- write operations has consistency problems
- write-through caching
	- completely write data to file before replying to client
	- inefficient when write is frequent
- commit operation
	- store write changes in cache memory
	- write to disk when commit

client chaching in NFS
	- cache read operations
		- inconsistency handled by timestamp
			- polling server
			- based on freshness of cached object

	- cache write operations
		- mark modified cache page as dirty and schedule page to be flushed to server asynchronously
	- asynchronous block input/output (bio) daemon
		- read/write done by blocks
		- spacial & temporal locality

file sharing semantics
- single processor - when a read follows a write, the return value of read is the value just written
- distributed system - obsolete values may be returned

4 ways of dealing with shared files in a distributed system:
- unix semantics - every operation on a file is instantly visible to all processes
- session semantics - no changes are visible to other processes until the file is closed
- immutable files - no updates possible
- transaction - all changes occur atomically

Andrew File System (AFS)
- infrequently updated shared files and local user files remain valid for long periods of time
- large local disk cache establishes a working set
	- assume small files
	- reads more than writes
	- sequential access
	- user-locality (used by one user only)
	- burstiness (temporal locality)
- whole-file serving - transfer entire contents to client
- whole-file caching - transfered file will be stored in the client's local disk
- callback promises - ensures cached files are updated after a client calls close()
- file update with one-copy update semantics is inefficient
- does not support concurrent updates

Slide 6

Clock synchronization
- all processes need to agree on the order in which events occur
- logical clocks
- physical clocks (real time)

- physical clock synchronization
	- change in time - dt
	- maximum drift rate - rho
	- 2 clocks can be at most 2(rho)(dt) apart
	- maximum time apart - delta
	- needs to synchronize clock every (delta)/2/(rho)

Christian's algorithm
- one time server (WWV receiver) and all other machines synchronize with the time server
- changes cannot be backward
- apply propagation time (t1-t0-I)/2
	- I - interrupt handling time

Berkeley algorithm
- time daemon polls every machine periodically
- computes average time
- tells other to advance clock or slow clock
- time daemon's time is set manually by operator periodically

Averaging algorithm
- decentralized algorithm
- divide time into fixed length intervals
- T0 - an agreed upon moment in the past
- R - a system parameter
- ith interval is [T0+iR, T0+(i+1)R)
- each machine broadcast its time at the start of an interval
- compute the average
	- discard highest and lowest time values

Internet Network Time Protocol (NTP)
- tree structure
- nodes at lower depth (strata) synchronize with their parents
- if a node fails, it degrades to the next strata
- modes:
	- multicast - periodically transmits time
	- procedure call - similar to Christian's algorithm
	- symmetric - used where high accuracy is needed

synchronized clocks
- at-most-once message delivery
	- each message carries a connection ID and a timestamp
	- server records the most-recent timestamp
	- server rejects any connection with a lower timestamp stored for that connection
	- periodically the current time is written to disk

logical clock synchronization
- happens-before relation (a->b)
	- in same process: if a happens before b, then a->b
	- in different processes: if 'a' is the event of a message, and 'b' is the event of the same message received by another process, then a->b
	- in different processes: processes do not exchange message (i.e. neither a->b nor b->a), these events are concurrent a||b
	- transitivity holds

Lamport's algorithm
- each process has a local counter, Li
- each event e that occurs at process pi is assigned a Lamport timestamp Li(e)

Global states
- garbage collection
- deadlocks
- termination

distributed snapshot
- cut of system's execution
- cut C is consistent iff for all e in Ci, f-> e => f in c

distributed snapshot algorithm
chandy-lamport snapshot recording algorithm
- 
TODO

election problem
- assumptions:
	- each process has a unique number
	- one process per machine
	- each process knows the process number of every other machines
	- processes do not know which processes are currently up and which ones are currently down
- coordinator has the high process number

the bully algorithm
- a process P sends an ELECTION messages to all processes with higher numbers
- if no one responds, P wins and becomes the coordinator
- otherwise, P is done and isn't the coordinator
- if a process receives an ELECTION message from a lower-number process, it replies ok and will take over the election

ring algorithm
- logically order processes in a ring
- any process notices that cooridinator is not functioning sends an ELECTION message to its neighbour
- neighbour pass the message with its process number attached to the list within the message
- after a cycle is complete, the process circulates a COORDINATOR message

Sharing in Distributed Systems
- mutual exclusion problem
- requirements:
	- safety
	- liveness
	- order

centralized algorithm
- one process elected as coordinator
- other processes ask coordinator for a lock
- coordinator queue the lock requests and grant lock to the first of queue if lock is available

- easy to implement
- fair
- no stavation
- single point of failure

distributed algorithm
- based on total ordering of events
- relies on timestamp
- when a process enters critical region, send a message to all other processes
- if other processes are not in the critical region, reply OK

- n point of failures, higher probability of failure
- process needs to include states
- slower, more complicated, more expensive, and less robust then centralized algorithm

token ring algorithm
- process that holds the token can enter a critical region; others block
- if the process no longer in critical region, it passes the token

- guarantees mutual exclusion
- no starvation
- need to regenerate token if it is lost
- recovery if a process crashes

Transaction

- characterization
	- read set (RS)
	- write set (WS)
	- base set (BS = RS union WS)

centralized transaction execution
- user application
- transaction manager
- scheduler
- recovery manager

distributed transaction execution
- user application
- transaction manager - distributed transaction execution model, replica control protocol
- scheduler - distributed concurrency control protocol
- recovery manager - local recovery protocol

properties of transactions

Atomicity - all or nothing
Conistency - correctness
Isolation - serializability
Durability - commited updates persist

isolation problems
- serializability
- incomplete results
	- anomalies
		- lost updates
		- inconsistent retrievals

execution schedule
- an order in which the operations of a set of transactions are executed

serial history
- conflict equivalence - the relative order of execution of the conflicting operations belonging to non-aborted transactions in two histories are the same

conflicts
- read-write
- write-write


Distributed Transaction Serializability

- local histories
- global history

- for global history to be serializable
	- each local history should be serializable
	- 2 conflicting operations should be in the same relative order in all of the local historeis where they appear together

Locking
- read lock (shared lock)
- write lock (exclusive lock)

Two-phase locking (2PL)
- phase 1: obtain locks
- lock point: begin to release locks
- phase 2: release locks

strict 2PL
- all locks must be released at once

deadlock
- wait-for graph
	- if transaction Ti waits for another transaction Tj to release a lock on an entity, then Ti->Tj in WFG

deadlock management
- prevention
- avoidance
- detection and recovery

distributed deadlock prevention
- pass WFG to other sites

timestamp ordering
- transaction Ti
- globally unique timestamp ts(Ti)
- transaction manager attaches the timestamp to all operations issued by the transaction
- each object has a write timestamp and a read time stamp
- rts(x) = largest timestamp of any read on x
- wts(x) = largest timestamp of any write on x
- algorithm:
	for Ri(x)
		if ts(Ti) < wts(x)
		then reject Ri(x)
		else {
			accept Ri(x)
			rts(x) <- ts(Ti
		}

	for Wi(x)
		if ts(Ti) < rts(x) or ts(Ti) < wts(x)
		then reject Wi(x)
		else {
			accept Wi(x)
			wts(x) <- ts(Ti)
		}

multiversion timestamp ordering
- associate version with timestamp
- Ri(x) becomes reading a version of x
- Wi(x) generates a new version of x, as long as Rj(xr) has not yet been processed
	ts(Ti) < ts(xr) < ts(Tj)



Slide 7 - replication

- advantages: reliability and performance
- disadvantages: replication transparency and consistency issues

object replication
- occur in the object level or in the middleware

strict consistency
- any read returns a value corrsponding to the result of the most recent write
- relies on absolute global time

linearizability
- read and write by all processes were executed in some serial order and each process' operations maintain the order specified
- timestamp based on real time

sequential consistency
- similar to linearizability but without timestamp
- similar to serializability
- processes -> switch -> merged operations
- requires transaction

Transactional replica consistency
- one-copy serializabilty
	- the effect of transactions performed by clients on replicated objects should be the same as if they had been performed one at-a-time on a single set of objects

Client-centric consistency
- eventual consistency
- only requires guarantees that updates will be propagated

- monotonic reads - read after reads; returns the same value or the most recent value
- monotonic writes - write followed by writes; write will be completed before other writes
- read your writes - effect of writes will always by seen by successive reads
- write follow reads - read return the most recent value then do the write


Replica placement
- mirroring
- push caches
- client caches

update propagation
- propagate notifications, logs, update operations
- server: push approach
- client: pull approach
- epidemic protocols: eventual consistency

primary-based protocol

primary copy remote-write protocol (primary stays in one location)
- forward requests to primary
- primary tells backups to update
- backup ack update
- reply client ack write complete

primary copy local-write protocol (primary moves)
- write request
- move x to new primary
- ack write complete to client
- primary tell backups to update
- backups ack update

active replication
- request is processed by all servers
- enforce order:
	- total ordered multicast
	- lamport timestamps
	- sequencer

replicated invocations problem
- client replicates invocation request
- all replicas see the same invocation
- object receives n invocation for n replica objects
- solution: let a coordinator forward invocation request/reply

quorum-based protocol
- assign a vote to each copy of a replicated object such that sum(Vi) = V
- each operation has to obtain a read quorum (Vr) to read and a write quorum (Vw) to write an object
- the following must hold:
	- Vr + Vw > V
	- Vw > V/2

Fault Tolerance

- reliability
- availability
- safety
- maintainability

- failure - deviation of a system from the behavior that is described in its specification
- error - the part of state which is incorrect
- fault - cause of an error

- fault -> causes -> error -> results in -> failure

- hard faults
- soft faults

Faults
- permanant fault
- incorrect design
- unstable or marginal components
- unstable environment
- operator mistake

Errors
- permanant error
- intermittent error
- transient error

Failures
- System failures

Failure models
- crash failure
- omission failure
- timing failure
- response failure
- arbitrary failure

Improve dependability
- mask failures by redundancy
	- information redundancy
	- time redundancy
	- physical redundancy
- a design that does not require simultaneous functioning of a substantial number of critical components

Hardware redundancy
- 2 computers, one acts as standby

Process redundancy
- flat (cycled graph) vs hierarchical (tree)

Management of replicated process
- primary copy
	- backups take over when primary failed
	- hierarchical
- replicated writes
	- active replication and quorum-based protocols
	- flat group
	- no single point of failure

k fault tolerence
- a system can survive faults in k components and still meet its specs
- safe failure requires k+1 processes
- arbitrary failures require 2k+1 processes
	- k failing processes can all generate the same result by chance
	- assumes processes are independent
	- processes gang up to produce wrong results -> General problem
		- so in this case k+2k+1 = 3k+1 processes are needed
	- assume communication failures do not occur


Communication failures
- point-to-point communication
	- TCP sends ACK
- RPC, RMI

Network partitioning & replication
- group of replica managers
	- partitioned into two or more subgroups
	- only members within a subgroup can communication with other members within the subgroup

Replica management with network partitioning
- optimistic approach
	- available copies with validation
		- let each partition perform updates freely
		- validate when partition is repaired and those that violate one-copy serializability are aborted

- pessimistic
	- quorum-based
	- reduce availability
	- updates only occur in the partition that has a majority of the replica managers

Quorum protocols for network partitioning
- handled by commit protocol
- each site has a vote Vi
- total number of votes is V
- abort quorum Va, commit quorum Vc
- Va + Vc > V where Va >= 0, Vc <= V
- before a transaction commits, must obtain a commit quorum Vc
- similarly for aborts; need Va


Transactional dependability
- maintain atomicity and durability
- focus is on data
- failures that affect ACID
	- transaction failures
	- system (site) failures
	- media failures
	- communication failures

Distribution reliability protocols
- commit protocols
- termination protocols
- recovery protocols

Two-phase commit (2PC)
- phase 1: coordinator gets the participants to ready to commit their writes
- phase 2: everybody commits
- rules:
	- coordinator aborts a transaction iff at least one participant votes to abort it
